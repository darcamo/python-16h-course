
<section>
    <div class="retangulo-preto">
    <h2>Funções</h2>
</section>

<section>
    <div class="retangulo-preto">
    <h2>Definindo novas Funções</h2>

    <!-- <pre><code data-trim>
         def shout(message="Hi"):
         print("%s!".format(message))

         shout() # Prints "Hi!"
         shout("I love python")
         shout(message="And keyword arguments")
         </code></pre> -->

    <ul>
        <li>Funções são definidas com a palavra chave <code>def</code>
            <code-terminal>>>> def fib(n):
...<span class="fragment" data-fragment-index="1">     """Imprime a série de Fibonacci até n. Essa função não retorna nada."""</span>
...     a, b = 0, 1
...     while a < n:
...         print(a, end=" ")
...         a, b = b, a+b
...     print()
>>> fib(1000)
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987

<span class="fragment" data-fragment-index="3">>>> fib
&ltfunction __main__.fib&gt
>>> f = fib
>>> f
&ltfunction __main__.fib&gt
>>> f(1000)  # Chama a função passando 1000 para o parâmetro n
0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
</span></code-terminal>
        </li>
        <li class="fragment" data-fragment-index="1">A primeira declaração na função pode ser uma string, que será usada como documentação (<span class="green">docstring</span>)
            <ul class="fragment" data-fragment-index="2">
                <li> Pode ser vista com <code class="python">fib?</code> no IPython ou <code class="python">help(fib)</code></li>
            </ul></li>
        <li class="fragment" data-fragment-index="3">Definir uma função introduz a mesma na tabela de símbolos atual</li>

        <!-- <li>Os argumentos das funções podem ter valores padrão</li>
             <li>Argumentos adicionais com valores padrão podem ser nomeados quando chamados (argumento com palavra chave</li> -->
    </ul>
</section>

<section>
    <div class="retangulo-preto">
    <h2>Funções com valor de retorno</h2>
    <ul>
        <li>Uma função pode ou não ter um <code>return</code></li>
        <li>Funções sem <code>return</code> retornam <code>None</code></li>
    </ul>
    <code-terminal>>>> def fib2(n):
...     """Retorna (lista) a série de Fibonacci até n."""
...     result = []  # Cria uma lista vazia
...     a, b = 0, 1
...     while a < n:
...         result.append(a)  # Adiciona um elemento na lista
...         a, b = b, a+b
...     return result
...
>>> f100 = fib2(100)    # chama a função
>>> f100  # Notem que f100 é uma lista
[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]</code-terminal>
</section>

<section>
    <div class="retangulo-preto">
    <h2>Parâmetros com valor padrão</h2>

    <ul>
        <li>Os parâmetros de uma função podem ter um <span class="green">valor padrão</span></li>
        <li>Isso permite chamar a função com menos parâmetros do que foram definidos</li>

        <!-- <li>Considere a função que retorna a posição de um
             móvel dada uma posição inicial, velocidade e
             aceleração \[s = s_0+v_0 t + \frac{1}{2}a t^2\]</li> -->
        <li class="fragment" data-fragment-index="1">Exemplo: <span class="green" style="margin-left: 3%;">\(s = s_0+v_0 t + \frac{1}{2}a t^2\)</span>
            <pre><code class="python">def calc_s(t, s0=0, v0=1, a=0.5):
"""Calcula posição final dados s0, v0, a e t."""
return s0 + v0*t + 0.5 * a * t**2</code></pre></li>
        <li class="fragment" data-fragment-index="4">Também é possível especificar um parâmetro pelo nome</li>
    </ul>

    <code-terminal class="fragment" data-fragment-index="3">>>> calc_s(5)  # Chama a função apenas com o parâmetro obrigatório
11.25
>>> calc_s(5, 10)  # Passa os 2 primeiros parâmetros
21.25
<span class="fragment" data-fragment-index="4">>>> calc_s(5, 10, a=1.0)  # Passa 't' e 's0' pela posição e 'a' pelo nome
27.5</span></code-terminal>
    <p class="fragment" data-fragment-index="5">Nota: Não use tipos mutáveis para valores padrão</p>
</section>

<section>
    <div class="retangulo-preto">
    <h2>Funções com quantidade variável de argumentos</h2>
    <ul>
        <li>Funções podem aceitar uma quantidade
            variável de argumentos tanto via posição quanto
            via palavra chave</li>
        <li class="fragment">Para isso use o prefixo
            <code>*</code> e/ou <code>**</code> antes
            do argumento final</li>
        <li class="fragment">Se houverem multiplos
            parâmetros via posição e nome use os dois
            prefixos
            <pre><code class="python" data-external="code/function_def.py"></code></pre></li>
    </ul>

    <code-terminal class="fragment">>>> my_func(1, 2, 3, "e", "já",  modelo="Fusca", cor="Amarelo")
1
2
(3, 'e', 'já')
{'cor': 'Amarelo', 'modelo': 'Fusca'}</code-terminal>

</section>

<section>
    <div class="retangulo-preto">
    <h2>Funções Anônimas: lambda functions</h2>

    <ul>
        <li>As vezes precisamos efetuar algum cálculo
            simples, que possivelmente utilizaremos uma
            única vez logo em seguida</li>
        <!-- <li class="fragment">Declarar uma função de maneira tradicional
             poderia ser <strong>trabalho demais só para isso</strong></li> -->
        <li class="fragment">Nesses casos podemos criar uma "<strong>função anônima</strong>"</li>
        <li class="fragment">Notação: <code>lambda variáveis: expressão</code>
            <code-terminal>>>> f = lambda a, b: a+b
>>> f(3, 4)
7
>>> f = lambda x: x**2
>>> f(4)
16</code-terminal></li>


    </ul>
</section>
